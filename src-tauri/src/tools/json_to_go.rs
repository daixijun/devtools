use crate::utils::{
    error::{DevToolError, DevToolResult},
    response::DevToolResponse,
    string_utils::StringUtils,
    code_formatter::CodeFormatter,
};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::{HashMap, HashSet};
use tauri::command;

/// Configuration options for JSON to Go conversion
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonToGoOptions {
    pub struct_name: String,
    pub exported_fields: bool,
    pub is_go_118_or_above: bool,
    pub is_go_124_or_above: bool,
    pub selected_tags: HashMap<String, bool>,
}

impl Default for JsonToGoOptions {
    fn default() -> Self {
        let mut selected_tags = HashMap::new();
        selected_tags.insert("json".to_string(), true);
        selected_tags.insert("yaml".to_string(), false);
        selected_tags.insert("gorm".to_string(), false);
        selected_tags.insert("db".to_string(), false);
        selected_tags.insert("sql".to_string(), false);
        selected_tags.insert("toml".to_string(), false);
        selected_tags.insert("env".to_string(), false);
        selected_tags.insert("ini".to_string(), false);

        Self {
            struct_name: "AutoGenerated".to_string(),
            exported_fields: true,
            is_go_118_or_above: true,
            is_go_124_or_above: false,
            selected_tags,
        }
    }
}

/// Represents a field in a Go struct with metadata
#[derive(Debug, Clone)]
pub struct GoField {
    pub name: String,
    pub field_type: String,
    pub json_key: String,
    pub is_nested: bool,
    pub is_array: bool,
    pub nested_fields: Option<Vec<GoField>>,
}

/// Main converter service for JSON to Go struct transformation
pub struct JsonToGoConverter;

/// Entry point command for Tauri backend
#[command]
pub fn convert_json_to_go(json_str: &str, options: JsonToGoOptions) -> DevToolResponse<String> {
    match JsonToGoConverter::convert_json_to_go_structs(json_str, options) {
        Ok(data) => DevToolResponse::success(data),
        Err(error) => DevToolResponse::error(error.to_string()),
    }
}

impl JsonToGoConverter {
    /// Primary conversion method that orchestrates the entire process
    pub fn convert_json_to_go_structs(
        json_str: &str,
        options: JsonToGoOptions,
    ) -> DevToolResult<String> {
        let json_value = Self::parse_json_string(json_str)?;
        let fields = Self::extract_fields_from_json(&json_value, &options.struct_name)?;
        let go_code = Self::generate_go_structs(&fields, &options)?;
        Ok(go_code)
    }

    /// Legacy method for backward compatibility
    pub fn convert(json_str: &str, options: JsonToGoOptions) -> DevToolResult<String> {
        Self::convert_json_to_go_structs(json_str, options)
    }
}

// JSON Parsing Module
impl JsonToGoConverter {
    /// Parse JSON string to structured Value
    fn parse_json_string(json_str: &str) -> DevToolResult<Value> {
        serde_json::from_str(json_str)
            .map_err(|e| DevToolError::ParseError("JSON".to_string(), e.to_string()))
    }

    /// Extract fields from JSON value based on its type
    fn extract_fields_from_json(
        json_value: &Value,
        parent_name: &str,
    ) -> DevToolResult<Vec<GoField>> {
        match json_value {
            Value::Object(map) => Self::extract_fields_from_object(map, parent_name),
            Value::Array(array) => Self::extract_fields_from_array(array, parent_name),
            _ => Ok(vec![]),
        }
    }

    /// Extract fields from JSON object
    fn extract_fields_from_object(
        map: &serde_json::Map<String, Value>,
        parent_name: &str,
    ) -> DevToolResult<Vec<GoField>> {
        let mut fields = Vec::new();
        for (key, value) in map {
            let field = Self::create_field_from_json_value(key, value, parent_name)?;
            fields.push(field);
        }
        Ok(fields)
    }

    /// Extract fields from JSON array
    fn extract_fields_from_array(
        array: &[Value],
        parent_name: &str,
    ) -> DevToolResult<Vec<GoField>> {
        if array.is_empty() {
            return Ok(vec![]);
        }

        if let Some(first_item) = array.first() {
            if first_item.is_object() {
                Self::extract_fields_from_json(first_item, parent_name)
            } else {
                let field_type = Self::infer_go_type_from_json_value(first_item);
                Ok(vec![GoField {
                    name: "Item".to_string(),
                    field_type: format!("[]{}", field_type),
                    json_key: "item".to_string(),
                    is_nested: false,
                    is_array: true,
                    nested_fields: None,
                }])
            }
        } else {
            Ok(vec![])
        }
    }
}

// Field Creation Module
impl JsonToGoConverter {
    /// Create a GoField from JSON key-value pair
    fn create_field_from_json_value(
        key: &str,
        value: &Value,
        parent_name: &str,
    ) -> DevToolResult<GoField> {
        match value {
            Value::Object(_) => Self::create_object_field(key, value, parent_name),
            Value::Array(array) => Self::create_array_field(key, array),
            _ => Self::create_primitive_field(key, value),
        }
    }

    /// Create a field for JSON object
    fn create_object_field(key: &str, value: &Value, _parent_name: &str) -> DevToolResult<GoField> {
        let nested_name = StringUtils::to_pascal_case(key);
        let nested_fields = Self::extract_fields_from_json(value, &nested_name)?;

        Ok(GoField {
            name: key.to_string(),
            field_type: nested_name,
            json_key: key.to_string(),
            is_nested: true,
            is_array: false,
            nested_fields: Some(nested_fields),
        })
    }

    /// Create a field for JSON array
    fn create_array_field(key: &str, array: &[Value]) -> DevToolResult<GoField> {
        if array.is_empty() {
            return Self::create_empty_array_field(key);
        }

        if let Some(first_item) = array.first() {
            if first_item.is_object() {
                Self::create_object_array_field(key, first_item)
            } else {
                Self::create_primitive_array_field(key, first_item)
            }
        } else {
            Self::create_empty_array_field(key)
        }
    }

    /// Create a field for primitive JSON value
    fn create_primitive_field(key: &str, value: &Value) -> DevToolResult<GoField> {
        let field_type = Self::infer_go_type_from_json_value(value);

        Ok(GoField {
            name: key.to_string(),
            field_type,
            json_key: key.to_string(),
            is_nested: false,
            is_array: false,
            nested_fields: None,
        })
    }

    /// Create a field for empty array
    fn create_empty_array_field(key: &str) -> DevToolResult<GoField> {
        Ok(GoField {
            name: key.to_string(),
            field_type: "[]interface{}".to_string(),
            json_key: key.to_string(),
            is_nested: false,
            is_array: true,
            nested_fields: None,
        })
    }

    /// Create a field for array of objects
    fn create_object_array_field(key: &str, first_item: &Value) -> DevToolResult<GoField> {
        let nested_name = StringUtils::to_pascal_case(key);
        let nested_fields = Self::extract_fields_from_json(first_item, &nested_name)?;

        Ok(GoField {
            name: key.to_string(),
            field_type: format!("[]{}", nested_name),
            json_key: key.to_string(),
            is_nested: true,
            is_array: true,
            nested_fields: Some(nested_fields),
        })
    }

    /// Create a field for array of primitive values
    fn create_primitive_array_field(key: &str, first_item: &Value) -> DevToolResult<GoField> {
        let element_type = Self::infer_go_type_from_json_value(first_item);

        Ok(GoField {
            name: key.to_string(),
            field_type: format!("[]{}", element_type),
            json_key: key.to_string(),
            is_nested: false,
            is_array: true,
            nested_fields: None,
        })
    }
}

// Type Inference Module
impl JsonToGoConverter {
    /// Infer Go type from JSON value
    fn infer_go_type_from_json_value(value: &Value) -> String {
        match value {
            Value::String(_) => "string".to_string(),
            Value::Number(num) => Self::infer_number_type(num),
            Value::Bool(_) => "bool".to_string(),
            Value::Null => "interface{}".to_string(),
            Value::Array(_) => "[]interface{}".to_string(),
            Value::Object(_) => "interface{}".to_string(),
        }
    }

    /// Infer Go numeric type from JSON number
    fn infer_number_type(num: &serde_json::Number) -> String {
        if num.is_i64() || num.is_u64() {
            "int".to_string()
        } else {
            "float64".to_string()
        }
    }
}


// Struct Generation Module
impl JsonToGoConverter {
    /// Generate all Go structs including nested ones
    fn generate_go_structs(fields: &[GoField], options: &JsonToGoOptions) -> DevToolResult<String> {
        let mut all_structs = String::new();
        let mut processed_structs = HashSet::new();
        let mut structs_to_generate = Vec::new();
        structs_to_generate.push((options.struct_name.clone(), fields.to_vec()));

        let mut index = 0;
        while index < structs_to_generate.len() {
            let (struct_name, struct_fields) = structs_to_generate[index].clone();

            if !processed_structs.contains(&struct_name) {
                processed_structs.insert(struct_name.clone());

                let struct_code = Self::generate_struct_definition(
                    &struct_name,
                    &struct_fields,
                    options,
                    &mut structs_to_generate,
                )?;
                all_structs.push_str(&struct_code);

                if index < structs_to_generate.len() - 1 {
                    all_structs.push_str("\n\n");
                }
            }

            index += 1;
        }

        Ok(CodeFormatter::format_go_code(&all_structs))
    }

    /// Generate a single struct definition
    fn generate_struct_definition(
        struct_name: &str,
        fields: &[GoField],
        options: &JsonToGoOptions,
        structs_to_generate: &mut Vec<(String, Vec<GoField>)>,
    ) -> DevToolResult<String> {
        let mut result = format!("type {} struct {{\n", struct_name);

        if fields.is_empty() {
            result.push_str("\t// Empty struct\n");
        } else {
            // Calculate maximum field name length for alignment
            let max_field_name_length = fields
                .iter()
                .map(|field| Self::get_field_name(field, options).len())
                .max()
                .unwrap_or(0);

            // Calculate maximum field type length for alignment
            let max_field_type_length = fields
                .iter()
                .map(|field| Self::determine_field_type(field, options, structs_to_generate).len())
                .max()
                .unwrap_or(0);

            // Ensure minimum alignment of 8 characters for field names
            let name_alignment = std::cmp::max(max_field_name_length + 1, 8);
            // Ensure minimum alignment of 8 characters for field types
            let type_alignment = std::cmp::max(max_field_type_length + 1, 8);

            for field in fields {
                let field_definition = Self::generate_field_definition(
                    field,
                    options,
                    structs_to_generate,
                    name_alignment,
                    type_alignment,
                );
                result.push_str(&format!("\t{}\n", field_definition));
            }
        }

        result.push_str("}");
        Ok(result)
    }

    /// Generate field definition with double alignment (field name and field type)
    fn generate_field_definition(
        field: &GoField,
        options: &JsonToGoOptions,
        structs_to_generate: &mut Vec<(String, Vec<GoField>)>,
        name_alignment: usize,
        type_alignment: usize,
    ) -> String {
        let field_name = Self::get_field_name(field, options);
        let tags = Self::generate_field_tags(field, options);
        let final_type = Self::determine_field_type(field, options, structs_to_generate);

        // Calculate padding needed for field name alignment
        let name_padding = name_alignment.saturating_sub(field_name.len());
        let name_padding_str = " ".repeat(name_padding);

        // Calculate padding needed for field type alignment
        let type_padding = type_alignment.saturating_sub(final_type.len());
        let type_padding_str = " ".repeat(type_padding);

        if tags.is_empty() {
            format!("{}{}{}", field_name, name_padding_str, final_type)
        } else {
            format!(
                "{}{}{}{}`{}`",
                field_name, name_padding_str, final_type, type_padding_str, tags
            )
        }
    }

    /// Get field name based on export options
    fn get_field_name(field: &GoField, options: &JsonToGoOptions) -> String {
        let clean_key = StringUtils::sanitize_field_name(&field.json_key, "Field");
        if options.exported_fields {
            StringUtils::to_pascal_case(&clean_key)
        } else {
            StringUtils::to_camel_case(&clean_key)
        }
    }

    /// Determine field type handling nested structs and Go version compatibility
    fn determine_field_type(
        field: &GoField,
        options: &JsonToGoOptions,
        structs_to_generate: &mut Vec<(String, Vec<GoField>)>,
    ) -> String {
        let base_type = if options.is_go_118_or_above {
            field.field_type.replace("interface{}", "any")
        } else {
            field.field_type.clone()
        };

        if field.is_nested && field.nested_fields.is_some() {
            Self::handle_nested_field_type(field, structs_to_generate)
        } else {
            Self::handle_simple_field_type(field, base_type)
        }
    }

    /// Handle nested field type generation
    fn handle_nested_field_type(
        field: &GoField,
        structs_to_generate: &mut Vec<(String, Vec<GoField>)>,
    ) -> String {
        let clean_key = StringUtils::sanitize_field_name(&field.json_key, "Field");
        let nested_struct_name = StringUtils::to_pascal_case(&clean_key);

        if !structs_to_generate
            .iter()
            .any(|(name, _)| name == &nested_struct_name)
        {
            structs_to_generate.push((
                nested_struct_name.clone(),
                field.nested_fields.as_ref().unwrap().clone(),
            ));
        }

        if field.is_array {
            format!("[]{}", nested_struct_name)
        } else {
            nested_struct_name
        }
    }

    /// Handle simple field type generation
    fn handle_simple_field_type(field: &GoField, base_type: String) -> String {
        if field.is_array && !base_type.starts_with("[]") {
            format!("[]{}", base_type)
        } else {
            base_type
        }
    }
}

// Tag Generation Module
impl JsonToGoConverter {
    /// Generate struct tags for a field
    fn generate_field_tags(field: &GoField, options: &JsonToGoOptions) -> String {
        let mut tags = Vec::new();

        for (tag_type, &is_selected) in &options.selected_tags {
            if !is_selected {
                continue;
            }

            let tag = match tag_type.as_str() {
                "json" => Self::create_json_tag(field, options),
                "yaml" => Self::create_simple_tag("yaml", &field.json_key),
                "gorm" => Self::create_gorm_tag(field),
                "db" => Self::create_simple_tag("db", &field.json_key),
                "sql" => Self::create_simple_tag("sql", &field.json_key),
                "toml" => Self::create_simple_tag("toml", &field.json_key),
                "env" => Self::create_simple_tag("env", &field.json_key.to_uppercase()),
                "ini" => Self::create_simple_tag("ini", &field.json_key),
                _ => continue,
            };

            tags.push(tag);
        }

        if tags.is_empty() {
            String::new()
        } else {
            tags.join(" ")
        }
    }

    /// Create JSON tag with version-specific options
    fn create_json_tag(field: &GoField, options: &JsonToGoOptions) -> String {
        let omitempty_option = if options.is_go_124_or_above {
            ",omitzero"
        } else {
            ",omitempty"
        };

        format!("json:\"{}{}\"", field.json_key, omitempty_option)
    }

    /// Create a simple tag
    fn create_simple_tag(tag_name: &str, tag_value: &str) -> String {
        format!("{tag_name}:\"{tag_value}\"")
    }

    /// Create GORM tag with proper column mapping
    fn create_gorm_tag(field: &GoField) -> String {
        format!("gorm:\"column:{}\"", field.json_key)
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_convert_json_to_go_structs() {
        let json = r#"{
            "name": "John",
            "age": 30,
            "address": {
                "street": "123 Main St",
                "city": "New York"
            }
        }"#;

        let options = JsonToGoOptions::default();
        let result = JsonToGoConverter::convert_json_to_go_structs(json, options);

        assert!(result.is_ok());
        let go_code = result.unwrap();
        assert!(go_code.contains("type AutoGenerated struct"));
        assert!(go_code.contains("Name    string"));
        assert!(go_code.contains("Age     int"));
    }

    #[test]
    fn test_naming_conversion() {
        assert_eq!(
            StringUtils::to_pascal_case("hello_world"),
            "HelloWorld"
        );
        assert_eq!(
            StringUtils::to_camel_case("hello_world"),
            "helloWorld"
        );
        assert_eq!(
            StringUtils::to_pascal_case("hello-world"),
            "HelloWorld"
        );
    }

    #[test]
    fn test_type_inference() {
        let json_str = r#""test""#;
        let json_value: Value = serde_json::from_str(json_str).unwrap();
        assert_eq!(
            JsonToGoConverter::infer_go_type_from_json_value(&json_value),
            "string"
        );

        let json_num = r#"42"#;
        let json_value: Value = serde_json::from_str(json_num).unwrap();
        assert_eq!(
            JsonToGoConverter::infer_go_type_from_json_value(&json_value),
            "int"
        );

        let json_bool = r#"true"#;
        let json_value: Value = serde_json::from_str(json_bool).unwrap();
        assert_eq!(
            JsonToGoConverter::infer_go_type_from_json_value(&json_value),
            "bool"
        );
    }

    #[test]
    fn test_field_name_sanitization() {
        // Test hyphens
        assert_eq!(
            StringUtils::sanitize_field_name("field-name", "Field"),
            "field_name"
        );

        // Test dots
        assert_eq!(
            StringUtils::sanitize_field_name("field.name", "Field"),
            "field_name"
        );

        // Test spaces
        assert_eq!(
            StringUtils::sanitize_field_name("field name", "Field"),
            "field_name"
        );

        // Test multiple special characters
        assert_eq!(
            StringUtils::sanitize_field_name("field-name.with spaces", "Field"),
            "field_name_with_spaces"
        );

        // Test leading numbers
        assert_eq!(
            StringUtils::sanitize_field_name("123field", "Field"),
            "Field_123field"
        );

        // Test leading special characters
        assert_eq!(StringUtils::sanitize_field_name("-field", "Field"), "_field");

        // Test empty string
        assert_eq!(StringUtils::sanitize_field_name("", "Field"), "Field");

        // Test only special characters
        assert_eq!(StringUtils::sanitize_field_name("---", "Field"), "Field");
    }

    #[test]
    fn test_json_with_special_chars() {
        let json = r#"{
            "user-name": "John",
            "user.age": 30,
            "address details": {
                "street.name": "123 Main St",
                "city-code": "NYC"
            }
        }"#;

        let options = JsonToGoOptions::default();
        let result = JsonToGoConverter::convert_json_to_go_structs(json, options);

        assert!(result.is_ok());
        let go_code = result.unwrap();

        // Check that field names are properly sanitized with proper alignment
        assert!(go_code.contains("UserName       string"));
        assert!(go_code.contains("UserAge        int"));
        assert!(go_code.contains("AddressDetails AddressDetails"));

        // Check that tags have proper quotes including omitempty
        assert!(go_code.contains(r#"json:"user-name,omitempty""#));
        assert!(go_code.contains(r#"json:"user.age,omitempty""#));
        assert!(go_code.contains(r#"json:"address details,omitempty""#));
        assert!(go_code.contains(r#"json:"street.name,omitempty""#));
        assert!(go_code.contains(r#"json:"city-code,omitempty""#));

        // Check nested struct name is properly sanitized with proper alignment
        assert!(go_code.contains("type AddressDetails struct"));
        assert!(go_code.contains("CityCode   string"));
        assert!(go_code.contains("StreetName string"));
    }

    #[test]
    fn test_nested_struct_with_special_chars() {
        let json = r#"{
            "user-data": {
                "personal-info": {
                    "first-name": "John",
                    "last-name": "Doe"
                },
                "contact-details": {
                    "email.address": "john@example.com",
                    "phone.number": "123-456-7890"
                }
            }
        }"#;

        let options = JsonToGoOptions::default();
        let result = JsonToGoConverter::convert_json_to_go_structs(json, options);

        assert!(result.is_ok());
        let go_code = result.unwrap();

        // Check main struct
        assert!(go_code.contains("type AutoGenerated struct"));
        assert!(go_code.contains("UserData UserData"));

        // Check nested struct names are properly sanitized
        assert!(go_code.contains("type PersonalInfo struct"));
        assert!(go_code.contains("type ContactDetails struct"));
        assert!(go_code.contains("type UserData struct"));

        // Check field names with proper alignment
        assert!(go_code.contains("FirstName string"));
        assert!(go_code.contains("LastName  string"));
        assert!(go_code.contains("EmailAddress string"));
        assert!(go_code.contains("PhoneNumber  string"));

        // Check tags have proper quotes including omitempty
        assert!(go_code.contains(r#"json:"first-name,omitempty""#));
        assert!(go_code.contains(r#"json:"last-name,omitempty""#));
        assert!(go_code.contains(r#"json:"email.address,omitempty""#));
        assert!(go_code.contains(r#"json:"phone.number,omitempty""#));
    }
}
